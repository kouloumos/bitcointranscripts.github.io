<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>schnorr on ₿itcoin 记录稿</title><link>https://www.kouloumos.com/bitcointranscripts.github.io/zh/tags/schnorr/</link><description>Recent content in schnorr on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 14 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.kouloumos.com/bitcointranscripts.github.io/zh/tags/schnorr/index.xml" rel="self" type="application/rss+xml"/><item><title>ROAST - Robust asynchronous Schnorr threshold signatures</title><link>https://www.kouloumos.com/bitcointranscripts.github.io/zh/tabconf/2022/2022-10-14-roast/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.kouloumos.com/bitcointranscripts.github.io/zh/tabconf/2022/2022-10-14-roast/</guid><description>论文：https://ia.cr/2022/550
幻灯片：https://slides.com/real-or-random/roast-tabconf22/
哈咯各位，我叫 Tim，在 Blockstream 工作。本次演讲的内容是我跟几位合作者联合工作的成果。
比特币中的 Schnorr 签名 最近，我们已经在比特币中支持了 Schnorr 签名，由 taproot 软分叉激活的 BIP340 引入。我们希望引入 Schnorr 签名并倾向于使用它而不是 ECDSA，有三大理由：一，Schnorr 签名的安全性有明确的证明，可以给理论工作者更强的信心；二，Schnorr 签名效率更高；三，最主要是，在 Schnorr 上我们可以更容易构造更高级的签名协议。
想象 比特币已经支持 Shnorr 签名的验证。一旦我们把验证能力做进了协议，我们就可以在此基础上开发许多东西并应用在链上。举个例子，你可以开发门限签名，还可以实现像 MuSig 和 MuSig2 这样的多签名协议。只要一个签名看起来是一个 Schnorr 签名，你就可以把它放到链上，是可以兼容的。为了支持 Schnorr 签名，我们必须更改共识层。但是，一旦有了 Schnorr 签名，我们就不再需要为使用更高级的签名协议而改造共识层，这是个好事情，因为改变共识层更难。
此外，有了这些协议，假设你在链上看到了一个 Schnorr 签名，你并不能知道它是否使用了门限签名协议或者多签名协议。这也提供了紧凑性，无论在构造签名的过程中发生了什么，最终发送到链上的都只有 32 字节。这也很好，因为区块空间是稀缺的。
门限签名 可能你在之前听说过 “multisig（多签名）” 这个词。“Multisig” 这个词更多用在比特币工程社区中，而 “门限签名” 更多用在学术社区中。假定我们有一个 “t-of-n” 的门限签名设置，这意味着 n 个签名者共有一个公钥，并且至少要 t 个签名人在线，才能签发一条消息。作为一种特殊情况，的确有一种 n-of-n 的情况，需要所有签名者都在场，这在学术文献中称为 “多签名”。但在这里，我们的用词会灵活一点，然后我们就讨论 t-of-n 的情形。
不可伪造性是最主要的安全特性，也就是说 t 个签名人应该可以创建一个签名，但如果到场的不足 t 个人，就不应能够创建出签名，即使 (t-1) 个恶意签名人彼此串通，也无法生成有效的签名。另一个重要特性是健壮性（robustness）：要是 t 个签名人真的想创建一个签名，就一定能做到。这是一种抗 Dod 特性，即使 (t-1) （译者注：原文如此，疑应为 “(n - t)”）希望阻止签名，这 t 个签名人也能生成签名。这就是我们希望实现的几个主要特性。</description></item><item><title>Taproot on hardware wallets</title><link>https://www.kouloumos.com/bitcointranscripts.github.io/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.kouloumos.com/bitcointranscripts.github.io/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</guid><description>开场（Jeff Gallas） 我非常高兴地宣布我们今天的第一位演讲者，来自 Specter 的 Stepan Snigirev，他是 Specter Solutions 的 CTO，有 3 年的开发比特币软件钱包（soft wallets）和硬件签名器（hard wallets）的经历。欢迎 Stepan。
概述（Stepan Snigirev） 我今天的演讲主题是 “在硬件签名器上支持 Taproot”。我们刚刚激活了 Taproot，非常棒，是在去年 11 月激活的。一些软件钱包已经开始集成了，而且甚至一些硬件签名器也开始集成了。现在大部分人用的都是单调的 “单密钥、单签名” 方案。我想讲讲我们可以用 Taproot 做什么。我觉得应该大家都知道了，所以我会讲快一点，然后我会讨论为什么在硬件签名器中集成 Taproot 是非常困难的、难点在哪里。如果我们无法在硬件钱包中集成，我们还有什么办法？
通过隐藏实现隐私 Taproot 非常出色。首先是它给了用户隐私性。在你观察区块链的时候，如果你看到一个单签名和单公钥的 taproot 地址，它里面可能实际上是一个公钥和一个脚本树。然后，这个公钥自身也可能凝结了一组公钥，而这棵脚本树可能非常高，是许许多多脚本的复杂集合。在里面你可以放置任意类型的时间锁，然后备份平时不会用到的私钥、仅在紧急情况下才启用它们。这意味着，所有复杂的花费条件，在链上看起来都是一样的。这是非常棒的事。甚至放在脚本中的公钥也可以代表着一组公钥，这就像是无限阶的密钥聚合。非常酷。
Miniscript（更安全的明文备份） 我个人会使用它的第一个理由是，它支持更好的明文备份。为什么现在没有人使用 Miniscript 或者复杂的比特币脚本？首先是因为比特币脚本复杂而不容易编写（在 Miniscript 出现之前）。其次是所有人都不使用它。这是一个鸡生蛋还是蛋生鸡的问题：每个人（90%）都使用单签名脚本，10% 的人使用多签名脚本，只有 0.3% 的人使用定制化的脚本。如果你使用一些定制化的脚本，你就暴露在了这 0.3% 里面。所有的链分析公司都知道，要是使用这样的脚本，那很有可能是同一个人。这样的隐私性非常糟，这就是障碍之一。
花费条件：or(HW, and(backup, timelock))
描述符：tr(HW, {and_v(v:pk(backup), older(timelock))})
Tapscript：&amp;lt;backup&amp;gt; OP_CHECKSIGVERIFY &amp;lt;timelock&amp;gt; OP_CHECKSEQUENCEVERIFY
（译者注：这段花费条件的意思是：一个硬件签名器随时可以花费这笔钱；同时，时间锁过期后，后备私钥也可以花费这笔钱。）
我个人会使用，我非常害怕把明文的钱包复原词（recovery phrases，应指种子词）放在我家里。如果有人得到了它，那我的钱就全部丢了。我个人的做法是使用一个不备份的硬件钱包，然后设置一个备用脚本，这个备用脚本带有时间锁，加上复原词就可以花费我的钱。然后，如果我遇到了什么意外，或者我的硬件钱包坏了，那么等待一段时间（也许半年）我就能拿回我的钱。但是，如果我的复原词被盗了，他们是没法立即偷走我的钱的（只要硬件钱包还在我手上的话）。我有足够多的时间，将资金迁移到一个新的装置上。但是，想想硬件签名器和 Miniscript 实现，现在还没有一个东西真正支持这个功能。太糟糕了。但实际上这并不是很难。在我给我们的硬件签名器集成 Miniscript 的时候，基本上我只花了一周的时间。我只要坐下来就可以开始开发了，因为它的说明真的写得非常好。Miniscript 有两个元素，其中一个你可以忽略，另一个是，如果你有一段可读的 policy 表达式，你就可以把它转成钱包的描述符。这有点复杂，但你不需要在硬件签名器里完成操作。第二部分是将钱包的描述符编译成实际的比特币脚本。这基本上只是把这些记号替换成比特币脚本的操作码，然后把派生出来的密钥放在正确的位置上。非常简单。然后硬件签名器就可以确定哪个输出是找零，并验证找零输出是从相同的描述符中派生出来的。这就行了。我想提一句，Ledger 团体最近做了很多工作来升级他们的比特币应用。他们在设计的时候就采用了 Miniscript 方法。虽然现在仅支持多签名功能，但很容易就能升级到支持定制化的 Miniscript，所以我很期待。至于硬件签名器，我不知道他们的计划。但至少会有两种硬件签名器将支持 Miniscript。</description></item></channel></rss>